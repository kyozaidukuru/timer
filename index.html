const canvas = document.getElementById("timer");
const ctx = canvas.getContext("2d");
let locked = false, remain = 0, last = 0;

// 音源の準備
const clickSound = new Audio("click.mp3");
const finishSound = new Audio("finish.mp3");

function resize() {
  const v = window.visualViewport;
  // サイズを 0.7 から 0.9 にアップして円盤を大きく
  const size = Math.min(v.width * 0.95, v.height * 0.8);
  canvas.width = canvas.height = size;
  draw();
}
window.addEventListener("resize", resize);

function draw() {
  const r = canvas.width / 2;
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.translate(r, r);

  const style = getComputedStyle(document.body);
  const fg = style.getPropertyValue('--fg');
  const arcColor = style.getPropertyValue('--arc');

  // 外枠
  ctx.strokeStyle = fg;
  ctx.lineWidth = 4;
  ctx.beginPath(); ctx.arc(0, 0, r * 0.85, 0, Math.PI * 2); ctx.stroke();

  // 目盛り
  for (let i = 0; i < 60; i++) {
    let a = i * Math.PI / 30 - Math.PI / 2;
    let len = i % 5 === 0 ? r * 0.10 : r * 0.05;
    ctx.beginPath();
    ctx.moveTo(Math.cos(a) * (r * 0.72), Math.sin(a) * (r * 0.72));
    ctx.lineTo(Math.cos(a) * (r * 0.72 + len), Math.sin(a) * (r * 0.72 + len));
    ctx.stroke();
  }

  // 残り時間の円弧（赤く塗られる部分）
  if (remain > 0) {
    ctx.fillStyle = arcColor;
    ctx.beginPath();
    ctx.moveTo(0, 0);
    // 12時の方向から時計回りに描画
    ctx.arc(0, 0, r * 0.70, -Math.PI / 2, -Math.PI / 2 + remain * 6 * Math.PI / 180);
    ctx.fill();
  }

  // 針
  let a = -Math.PI / 2 + remain * 6 * Math.PI / 180;
  ctx.strokeStyle = "red"; ctx.lineWidth = 4;
  ctx.beginPath();
  ctx.moveTo(0, 0);
  ctx.lineTo(Math.cos(a) * r * 0.65, Math.sin(a) * r * 0.65);
  ctx.stroke();
  ctx.fillStyle = "red";
  ctx.beginPath(); ctx.arc(0, 0, 8, 0, Math.PI * 2); ctx.fill();

  // 数字
  ctx.fillStyle = fg;
  ctx.font = `bold ${r * 0.12}px sans-serif`;
  for (let i = 0; i < 12; i++) {
    let ang = i * Math.PI / 6 - Math.PI / 2;
    let x = Math.cos(ang) * r * 0.90;
    let y = Math.sin(ang) * r * 0.90;
    let t = i * 5;
    let w = ctx.measureText(t).width;
    ctx.fillText(t, x - w / 2, y + (r * 0.04));
  }

  ctx.setTransform(1, 0, 0, 1, 0, 0);
}

canvas.onclick = e => {
  if (locked) return;

  // 【重要】クリック時に音源を一度再生（無音でも可）してロック解除
  clickSound.play().catch(() => {});
  finishSound.pause(); // 前の音を止める
  finishSound.currentTime = 0;

  const r = canvas.width / 2;
  const rect = canvas.getBoundingClientRect();
  let x = (e.clientX - rect.left) - r;
  let y = (e.clientY - rect.top) - r;
  let a = Math.atan2(y, x) + Math.PI / 2;
  if (a < 0) a += Math.PI * 2;
  remain = Math.round(a * 180 / Math.PI / 6);
  
  if(remain === 0 && a > Math.PI) remain = 0; // 0付近の誤作動防止
  
  clickSound.play();
  draw();
};

function tick(t) {
  if (!last) last = t;
  let d = (t - last) / 1000;
  last = t;

  if (remain > 0) {
    let prevRemain = remain;
    remain -= d / 60;
    
    if (remain <= 0) {
      remain = 0;
      // 終了の音を鳴らす
      finishSound.play().catch(err => console.error("Audio error:", err));
      if(navigator.vibrate) navigator.vibrate([200, 100, 200]);
    }
  }
  draw();
  requestAnimationFrame(tick);
}
requestAnimationFrame(tick);

// ボタン類
document.getElementById("lockBtn").onclick = () => {
  locked = !locked;
  const b = document.getElementById("lockBtn");
  b.textContent = locked ? "固定中" : "固定";
  b.classList.toggle("locked", locked);
};
document.getElementById("modeBtn").onclick = () => {
  document.body.classList.toggle("dark");
  draw(); // 色が変わるので再描画
};
document.getElementById("fsBtn").onclick = () => {
  if (!document.fullscreenElement) {
    document.documentElement.requestFullscreen();
  } else {
    document.exitFullscreen();
  }
};

resize();
